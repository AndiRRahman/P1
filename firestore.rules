/**
 * Core Philosophy: This ruleset enforces a Role-Based Access Control (RBAC) model
 * with three distinct levels: Guests (unauthenticated), Customers (authenticated),
 * and Admins. The primary goal is to provide public read access to product data
 * while strictly securing user-specific data (profiles, orders, carts) to the
 * data owner or an administrator for support purposes.
 *
 * Data Structure: The data is organized into three main areas:
 * 1. /products/{productId}: A top-level public collection for all product listings.
 * 2. /users/{userId}/...: A user-centric hierarchy where each user's private
 *    data (profile, orders, cart) is nested under their unique ID.
 * 3. A `role` field within each user's document in `/users/{userId}` determines
 *    their privilege level ('admin' or 'customer').
 *
 * Key Security Decisions:
 * - Admin Role Verification: A user is considered an admin if their document at
 *   `/users/{request.auth.uid}` has a `role` field equal to 'admin'. This requires
 *   a `get()` call within rules but is the most direct way to manage roles.
 * - Strict User Data Segregation: All user-specific data is stored under a path
 *   containing the user's ID (e.g., /users/{userId}). Security rules leverage this
 *   path-based ownership to ensure a user can only ever access their own data tree.
 * - Admin Read-All Access: Admins are granted broad read access (`get`, `list`)
 *   across the `users` and `orders` collections for management purposes.
 * - No User Listing for non-admins: The ability to query the entire /users collection is explicitly
 *   disabled for non-admins to protect user privacy and prevent data scraping.
 * - Client-Side Role Immutability: The `role` field on a user document cannot be changed
 *   by any client-side request to prevent privilege escalation. Roles must be managed
 *   from a trusted server environment using the Admin SDK or directly in the console.
 * - Prototyping Flexibility: These rules focus on authorization (who can access what)
 *   and relational integrity, but intentionally do not validate the specific shape
 *   or data types of documents. This allows the application schema to evolve

 *   rapidly during development without requiring constant rule updates.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    //================================================================================
    // Helper Functions
    //================================================================================

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the requesting user has admin privileges by reading their
     * own user document.
     */
    function isAdmin() {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    /**
     * Checks if the requesting user's UID matches the provided userId.
     * This is the foundation of the user ownership model.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Combines owner and admin checks for resources that can be accessed
     * by either the owner or an administrator (e.g., user profiles, orders).
     */
    function isOwnerOrAdmin(userId) {
      return isOwner(userId) || isAdmin();
    }
    
    /**
     * Ensures an update or delete operation is targeting an existing document.
     * Prevents operations on non-existent paths.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Validates that the `id` field within a new user document matches the
     * document's ID in the path, ensuring relational integrity on creation.
     */
    function hasValidUserId(userId) {
      return request.resource.data.id == userId;
    }
    
    /**
     * Ensures the `id` field of a user document cannot be changed after creation.
     */
    function isUserIdImmutable() {
      return request.resource.data.id == resource.data.id;
    }

     /**
     * Ensures the `role` field cannot be changed by the client.
     */
    function isRoleImmutable() {
      return request.resource.data.role == resource.data.role;
    }

    /**
     * Validates that the `userId` field within a new subcollection document
     * (e.g., Order, CartItem) matches the user's ID in the path.
     */
    function hasValidOwnerId(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * Ensures the `userId` field of a document cannot be changed after creation,
     * preventing a document from being reassigned to another user.
     */
    function isOwnerIdImmutable() {
      return request.resource.data.userId == resource.data.userId;
    }


    //================================================================================
    // Collection Rules
    //================================================================================

    /**
     * @description Publicly readable product catalog. Writes are restricted to admins.
     * @path /products/{productId}
     * @allow (get) Any user, signed in or not, can view a specific product.
     * @allow (create) An admin can create a new product.
     * @deny (update) A regular user cannot update a product's price.
     * @principle Public read access for general data, with role-based write restrictions.
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();
    }

    /**
     * @description User profile data. Users can create and manage their own profile.
     *   Admins can view/edit profiles for support. Listing all users is allowed for admins.
     * @path /users/{userId}
     * @allow (get) A user with uid 'user123' can get '/users/user123'. An admin can get any user.
     * @allow (create) A new user with uid 'newUser' can create a document at '/users/newUser'.
     * @allow (list) An admin can list all documents in the '/users' collection.
     * @deny (get) A user with uid 'userABC' cannot get '/users/userXYZ'.
     * @principle Enforces strict data ownership and privacy, with admin override for support.
     */
    match /users/{userId} {
      allow get: if isOwnerOrAdmin(userId);
      allow list: if isAdmin();
      allow create: if isOwner(userId) && hasValidUserId(userId);
      allow update: if isOwnerOrAdmin(userId) && isExistingDoc() && isUserIdImmutable() && isRoleImmutable();
      allow delete: if isOwnerOrAdmin(userId) && isExistingDoc();
    }

    /**
     * @description A user's order history. Only the user or an admin can access.
     * @path /users/{userId}/orders/{orderId}
     * @allow (create) User 'user123' can create an order at '/users/user123/orders/order456'.
     * @allow (list) User 'user123' can list all their orders at '/users/user123/orders'.
     * @deny (get) User 'userABC' cannot get an order from '/users/userXYZ/orders/order789'.
     * @principle Path-based security inherits ownership from the parent document path.
     */
    match /users/{userId}/orders/{orderId} {
      allow get, list: if isOwnerOrAdmin(userId);
      allow create: if isOwner(userId) && hasValidOwnerId(userId);
      allow update: if isOwnerOrAdmin(userId) && isExistingDoc() && isOwnerIdImmutable();
      allow delete: if isOwnerOrAdmin(userId) && isExistingDoc();
    }

    /**
     * @description Collection Group rule for 'orders'. Allows an admin to query across all users' orders.
     * @path /{path=**}/orders/{orderId}
     * @allow (list) An admin can perform a collection group query on 'orders'.
     * @principle Enables admin-specific cross-user data aggregation.
     */
    match /{path=**}/orders/{orderId} {
      allow list: if isAdmin();
    }
    
    /**
     * @description Items within a specific order. Access rules are inherited from the parent order.
     * @path /users/{userId}/orders/{orderId}/orderItems/{orderItemId}
     * @allow (list) User 'user123' can list items for their own order.
     * @deny (create) User 'userABC' cannot create an item in another user's order.
     * @principle Deeply nested subcollections are secured by checking ownership at the top-level path segment.
     */
    match /users/{userId}/orders/{orderId}/orderItems/{orderItemId} {
      allow get, list: if isOwnerOrAdmin(userId);
      allow create: if isOwner(userId);
      allow update, delete: if isOwnerOrAdmin(userId) && isExistingDoc();
    }

    /**
     * @description A user's private shopping cart. Only the user can access their own cart.
     *   Admins do not have access to a user's cart to ensure privacy.
     * @path /users/{userId}/cart/{cartItemId}
     * @allow (create) User 'user123' can add an item to '/users/user123/cart/'.
     * @deny (get) An admin cannot view the cart of 'user123'.
     * @deny (list) User 'userABC' cannot list the cart items of 'user123'.
     * @principle Enforces strict user-only ownership for highly private data.
     */
    match /users/{userId}/cart/{cartItemId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && hasValidOwnerId(userId);
      allow update: if isOwner(userId) && isExistingDoc() && isOwnerIdImmutable();
      allow delete: if isOwner(userId) && isExistingDoc();
    }

    /**
     * @description Legacy collection for admin roles. No longer used in favor of the
     * `role` field in the user document, but kept here for reference and to be explicitly secured.
     */
    match /roles_admin/{userId} {
      allow read, write: if false;
    }
  }
}
